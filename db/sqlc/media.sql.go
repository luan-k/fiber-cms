// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: media.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const countTotalMedia = `-- name: CountTotalMedia :one
SELECT COUNT(*) AS total FROM media
`

func (q *Queries) CountTotalMedia(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTotalMedia)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createMedia = `-- name: CreateMedia :one
INSERT INTO media (
    name,
    description,
    alt,
    media_path,
    user_id,
    file_size,
    mime_type,
    width,
    height,
    duration,
    original_filename
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, name, description, alt, media_path, user_id, created_at, changed_at, file_size, mime_type, width, height, duration, original_filename, metadata
`

type CreateMediaParams struct {
	Name             string `json:"name"`
	Description      string `json:"description"`
	Alt              string `json:"alt"`
	MediaPath        string `json:"media_path"`
	UserID           int64  `json:"user_id"`
	FileSize         int64  `json:"file_size"`
	MimeType         string `json:"mime_type"`
	Width            int32  `json:"width"`
	Height           int32  `json:"height"`
	Duration         int32  `json:"duration"`
	OriginalFilename string `json:"original_filename"`
}

func (q *Queries) CreateMedia(ctx context.Context, arg CreateMediaParams) (Medium, error) {
	row := q.db.QueryRowContext(ctx, createMedia,
		arg.Name,
		arg.Description,
		arg.Alt,
		arg.MediaPath,
		arg.UserID,
		arg.FileSize,
		arg.MimeType,
		arg.Width,
		arg.Height,
		arg.Duration,
		arg.OriginalFilename,
	)
	var i Medium
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Alt,
		&i.MediaPath,
		&i.UserID,
		&i.CreatedAt,
		&i.ChangedAt,
		&i.FileSize,
		&i.MimeType,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.OriginalFilename,
		&i.Metadata,
	)
	return i, err
}

const createPostMedia = `-- name: CreatePostMedia :one
INSERT INTO post_media (
    post_id,
    media_id,
    "order"
) VALUES (
    $1, $2, $3
) RETURNING post_id, media_id, "order"
`

type CreatePostMediaParams struct {
	PostID  int64 `json:"post_id"`
	MediaID int64 `json:"media_id"`
	Order   int32 `json:"order"`
}

func (q *Queries) CreatePostMedia(ctx context.Context, arg CreatePostMediaParams) (PostMedium, error) {
	row := q.db.QueryRowContext(ctx, createPostMedia, arg.PostID, arg.MediaID, arg.Order)
	var i PostMedium
	err := row.Scan(&i.PostID, &i.MediaID, &i.Order)
	return i, err
}

const deleteMedia = `-- name: DeleteMedia :exec
DELETE FROM media
WHERE id = $1
`

func (q *Queries) DeleteMedia(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMedia, id)
	return err
}

const deleteMediaByUserID = `-- name: DeleteMediaByUserID :exec
DELETE FROM media
WHERE user_id = $1
`

func (q *Queries) DeleteMediaByUserID(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, deleteMediaByUserID, userID)
	return err
}

const deleteMediaPosts = `-- name: DeleteMediaPosts :exec
DELETE FROM post_media
WHERE media_id = $1
`

func (q *Queries) DeleteMediaPosts(ctx context.Context, mediaID int64) error {
	_, err := q.db.ExecContext(ctx, deleteMediaPosts, mediaID)
	return err
}

const deletePostMedia = `-- name: DeletePostMedia :exec
DELETE FROM post_media
WHERE post_id = $1 AND media_id = $2
`

type DeletePostMediaParams struct {
	PostID  int64 `json:"post_id"`
	MediaID int64 `json:"media_id"`
}

func (q *Queries) DeletePostMedia(ctx context.Context, arg DeletePostMediaParams) error {
	_, err := q.db.ExecContext(ctx, deletePostMedia, arg.PostID, arg.MediaID)
	return err
}

const deletePostMedias = `-- name: DeletePostMedias :exec
DELETE FROM post_media
WHERE post_id = $1
`

func (q *Queries) DeletePostMedias(ctx context.Context, postID int64) error {
	_, err := q.db.ExecContext(ctx, deletePostMedias, postID)
	return err
}

const getMedia = `-- name: GetMedia :one
SELECT id, name, description, alt, media_path, user_id, created_at, changed_at, file_size, mime_type, width, height, duration, original_filename, metadata FROM media
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetMedia(ctx context.Context, id int64) (Medium, error) {
	row := q.db.QueryRowContext(ctx, getMedia, id)
	var i Medium
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Alt,
		&i.MediaPath,
		&i.UserID,
		&i.CreatedAt,
		&i.ChangedAt,
		&i.FileSize,
		&i.MimeType,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.OriginalFilename,
		&i.Metadata,
	)
	return i, err
}

const getMediaByPost = `-- name: GetMediaByPost :many
SELECT m.id, m.name, m.description, m.alt, m.media_path, m.user_id, m.created_at, m.changed_at, m.file_size, m.mime_type, m.width, m.height, m.duration, m.original_filename, m.metadata FROM media m
JOIN post_media pm ON m.id = pm.media_id
WHERE pm.post_id = $1
ORDER BY pm."order", m.created_at
`

func (q *Queries) GetMediaByPost(ctx context.Context, postID int64) ([]Medium, error) {
	rows, err := q.db.QueryContext(ctx, getMediaByPost, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Medium{}
	for rows.Next() {
		var i Medium
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Alt,
			&i.MediaPath,
			&i.UserID,
			&i.CreatedAt,
			&i.ChangedAt,
			&i.FileSize,
			&i.MimeType,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.OriginalFilename,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaByUser = `-- name: GetMediaByUser :many
SELECT id, name, description, alt, media_path, user_id, created_at, changed_at, file_size, mime_type, width, height, duration, original_filename, metadata FROM media
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type GetMediaByUserParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetMediaByUser(ctx context.Context, arg GetMediaByUserParams) ([]Medium, error) {
	rows, err := q.db.QueryContext(ctx, getMediaByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Medium{}
	for rows.Next() {
		var i Medium
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Alt,
			&i.MediaPath,
			&i.UserID,
			&i.CreatedAt,
			&i.ChangedAt,
			&i.FileSize,
			&i.MimeType,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.OriginalFilename,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaPostCount = `-- name: GetMediaPostCount :one
SELECT COUNT(*) FROM post_media
WHERE media_id = $1
`

func (q *Queries) GetMediaPostCount(ctx context.Context, mediaID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getMediaPostCount, mediaID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPopularMedia = `-- name: GetPopularMedia :many
SELECT 
    m.id, m.name, m.description, m.alt, m.media_path, m.user_id, m.created_at, m.changed_at, m.file_size, m.mime_type, m.width, m.height, m.duration, m.original_filename, m.metadata,
    COUNT(pm.post_id) as post_count
FROM media m
JOIN post_media pm ON m.id = pm.media_id
GROUP BY m.id, m.name, m.description, m.alt, m.media_path, m.user_id, m.created_at, m.changed_at, m.file_size, m.mime_type, m.width, m.height, m.duration, m.original_filename, m.metadata
HAVING COUNT(pm.post_id) > 0
ORDER BY COUNT(pm.post_id) DESC
LIMIT $1
`

type GetPopularMediaRow struct {
	ID               int64           `json:"id"`
	Name             string          `json:"name"`
	Description      string          `json:"description"`
	Alt              string          `json:"alt"`
	MediaPath        string          `json:"media_path"`
	UserID           int64           `json:"user_id"`
	CreatedAt        time.Time       `json:"created_at"`
	ChangedAt        time.Time       `json:"changed_at"`
	FileSize         int64           `json:"file_size"`
	MimeType         string          `json:"mime_type"`
	Width            int32           `json:"width"`
	Height           int32           `json:"height"`
	Duration         int32           `json:"duration"`
	OriginalFilename string          `json:"original_filename"`
	Metadata         json.RawMessage `json:"metadata"`
	PostCount        int64           `json:"post_count"`
}

func (q *Queries) GetPopularMedia(ctx context.Context, limit int32) ([]GetPopularMediaRow, error) {
	rows, err := q.db.QueryContext(ctx, getPopularMedia, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPopularMediaRow{}
	for rows.Next() {
		var i GetPopularMediaRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Alt,
			&i.MediaPath,
			&i.UserID,
			&i.CreatedAt,
			&i.ChangedAt,
			&i.FileSize,
			&i.MimeType,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.OriginalFilename,
			&i.Metadata,
			&i.PostCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostMediaCount = `-- name: GetPostMediaCount :one
SELECT COUNT(*) FROM post_media
WHERE post_id = $1
`

func (q *Queries) GetPostMediaCount(ctx context.Context, postID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPostMediaCount, postID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPostWithMedia = `-- name: GetPostWithMedia :one
SELECT 
    p.id, p.title, p.description, p.content, p.user_id, p.username, p.url, p.created_at, p.changed_at,
    COALESCE(
        json_agg(
            json_build_object(
                'id', m.id,
                'name', m.name,
                'description', m.description,
                'alt', m.alt,
                'media_path', m.media_path,
                'user_id', m.user_id,
                'created_at', m.created_at,
                'changed_at', m.changed_at,
                'order', pm."order"
            ) ORDER BY pm."order", m.created_at
        ) FILTER (WHERE m.id IS NOT NULL),
        '[]'::json
    ) as media
FROM posts p
LEFT JOIN post_media pm ON p.id = pm.post_id
LEFT JOIN media m ON pm.media_id = m.id
WHERE p.id = $1
GROUP BY p.id, p.title, p.description, p.content, p.user_id, p.username, p.url, p.created_at, p.changed_at
`

type GetPostWithMediaRow struct {
	ID          int64       `json:"id"`
	Title       string      `json:"title"`
	Description string      `json:"description"`
	Content     string      `json:"content"`
	UserID      int64       `json:"user_id"`
	Username    string      `json:"username"`
	Url         string      `json:"url"`
	CreatedAt   time.Time   `json:"created_at"`
	ChangedAt   time.Time   `json:"changed_at"`
	Media       interface{} `json:"media"`
}

func (q *Queries) GetPostWithMedia(ctx context.Context, id int64) (GetPostWithMediaRow, error) {
	row := q.db.QueryRowContext(ctx, getPostWithMedia, id)
	var i GetPostWithMediaRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Content,
		&i.UserID,
		&i.Username,
		&i.Url,
		&i.CreatedAt,
		&i.ChangedAt,
		&i.Media,
	)
	return i, err
}

const getPostsByUserWithMedia = `-- name: GetPostsByUserWithMedia :many
SELECT 
    p.id, p.title, p.description, p.content, p.user_id, p.username, p.url, p.created_at, p.changed_at,
    COALESCE(
        json_agg(
            json_build_object(
                'id', m.id,
                'name', m.name,
                'description', m.description,
                'alt', m.alt,
                'media_path', m.media_path,
                'user_id', m.user_id,
                'created_at', m.created_at,
                'changed_at', m.changed_at,
                'order', pm."order"
            ) ORDER BY pm."order", m.created_at
        ) FILTER (WHERE m.id IS NOT NULL),
        '[]'::json
    ) as media
FROM posts p
LEFT JOIN post_media pm ON p.id = pm.post_id
LEFT JOIN media m ON pm.media_id = m.id
WHERE p.user_id = $1
GROUP BY p.id, p.title, p.description, p.content, p.user_id, p.username, p.url, p.created_at, p.changed_at
ORDER BY p.created_at DESC
LIMIT $2
OFFSET $3
`

type GetPostsByUserWithMediaParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetPostsByUserWithMediaRow struct {
	ID          int64       `json:"id"`
	Title       string      `json:"title"`
	Description string      `json:"description"`
	Content     string      `json:"content"`
	UserID      int64       `json:"user_id"`
	Username    string      `json:"username"`
	Url         string      `json:"url"`
	CreatedAt   time.Time   `json:"created_at"`
	ChangedAt   time.Time   `json:"changed_at"`
	Media       interface{} `json:"media"`
}

func (q *Queries) GetPostsByUserWithMedia(ctx context.Context, arg GetPostsByUserWithMediaParams) ([]GetPostsByUserWithMediaRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByUserWithMedia, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPostsByUserWithMediaRow{}
	for rows.Next() {
		var i GetPostsByUserWithMediaRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Content,
			&i.UserID,
			&i.Username,
			&i.Url,
			&i.CreatedAt,
			&i.ChangedAt,
			&i.Media,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserMediaCount = `-- name: GetUserMediaCount :one
SELECT COUNT(*) FROM media
WHERE user_id = $1
`

func (q *Queries) GetUserMediaCount(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUserMediaCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listMedia = `-- name: ListMedia :many
SELECT id, name, description, alt, media_path, user_id, created_at, changed_at, file_size, mime_type, width, height, duration, original_filename, metadata FROM media
ORDER BY created_at DESC
LIMIT $1
OFFSET $2
`

type ListMediaParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListMedia(ctx context.Context, arg ListMediaParams) ([]Medium, error) {
	rows, err := q.db.QueryContext(ctx, listMedia, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Medium{}
	for rows.Next() {
		var i Medium
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Alt,
			&i.MediaPath,
			&i.UserID,
			&i.CreatedAt,
			&i.ChangedAt,
			&i.FileSize,
			&i.MimeType,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.OriginalFilename,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMediaWithPostCount = `-- name: ListMediaWithPostCount :many
SELECT 
    m.id, m.name, m.description, m.alt, m.media_path, m.user_id, m.created_at, m.changed_at, m.file_size, m.mime_type, m.width, m.height, m.duration, m.original_filename, m.metadata,
    COUNT(pm.post_id) as post_count
FROM media m
LEFT JOIN post_media pm ON m.id = pm.media_id
GROUP BY m.id, m.name, m.description, m.alt, m.media_path, m.user_id, m.created_at, m.changed_at, m.file_size, m.mime_type, m.width, m.height, m.duration, m.original_filename, m.metadata
ORDER BY m.created_at DESC
LIMIT $1
OFFSET $2
`

type ListMediaWithPostCountParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListMediaWithPostCountRow struct {
	ID               int64           `json:"id"`
	Name             string          `json:"name"`
	Description      string          `json:"description"`
	Alt              string          `json:"alt"`
	MediaPath        string          `json:"media_path"`
	UserID           int64           `json:"user_id"`
	CreatedAt        time.Time       `json:"created_at"`
	ChangedAt        time.Time       `json:"changed_at"`
	FileSize         int64           `json:"file_size"`
	MimeType         string          `json:"mime_type"`
	Width            int32           `json:"width"`
	Height           int32           `json:"height"`
	Duration         int32           `json:"duration"`
	OriginalFilename string          `json:"original_filename"`
	Metadata         json.RawMessage `json:"metadata"`
	PostCount        int64           `json:"post_count"`
}

func (q *Queries) ListMediaWithPostCount(ctx context.Context, arg ListMediaWithPostCountParams) ([]ListMediaWithPostCountRow, error) {
	rows, err := q.db.QueryContext(ctx, listMediaWithPostCount, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMediaWithPostCountRow{}
	for rows.Next() {
		var i ListMediaWithPostCountRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Alt,
			&i.MediaPath,
			&i.UserID,
			&i.CreatedAt,
			&i.ChangedAt,
			&i.FileSize,
			&i.MimeType,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.OriginalFilename,
			&i.Metadata,
			&i.PostCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostsWithMedia = `-- name: ListPostsWithMedia :many
SELECT 
    p.id, p.title, p.description, p.content, p.user_id, p.username, p.url, p.created_at, p.changed_at,
    COALESCE(
        json_agg(
            json_build_object(
                'id', m.id,
                'name', m.name,
                'description', m.description,
                'alt', m.alt,
                'media_path', m.media_path,
                'user_id', m.user_id,
                'created_at', m.created_at,
                'changed_at', m.changed_at,
                'order', pm."order"
            ) ORDER BY pm."order", m.created_at
        ) FILTER (WHERE m.id IS NOT NULL),
        '[]'::json
    ) as media
FROM posts p
LEFT JOIN post_media pm ON p.id = pm.post_id
LEFT JOIN media m ON pm.media_id = m.id
GROUP BY p.id, p.title, p.description, p.content, p.user_id, p.username, p.url, p.created_at, p.changed_at
ORDER BY p.created_at DESC
LIMIT $1
OFFSET $2
`

type ListPostsWithMediaParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListPostsWithMediaRow struct {
	ID          int64       `json:"id"`
	Title       string      `json:"title"`
	Description string      `json:"description"`
	Content     string      `json:"content"`
	UserID      int64       `json:"user_id"`
	Username    string      `json:"username"`
	Url         string      `json:"url"`
	CreatedAt   time.Time   `json:"created_at"`
	ChangedAt   time.Time   `json:"changed_at"`
	Media       interface{} `json:"media"`
}

func (q *Queries) ListPostsWithMedia(ctx context.Context, arg ListPostsWithMediaParams) ([]ListPostsWithMediaRow, error) {
	rows, err := q.db.QueryContext(ctx, listPostsWithMedia, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPostsWithMediaRow{}
	for rows.Next() {
		var i ListPostsWithMediaRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Content,
			&i.UserID,
			&i.Username,
			&i.Url,
			&i.CreatedAt,
			&i.ChangedAt,
			&i.Media,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMediaByName = `-- name: SearchMediaByName :many
SELECT id, name, description, alt, media_path, user_id, created_at, changed_at, file_size, mime_type, width, height, duration, original_filename, metadata FROM media
WHERE name ILIKE '%' || $1 || '%' OR description ILIKE '%' || $1 || '%'
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type SearchMediaByNameParams struct {
	Column1 sql.NullString `json:"column_1"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

func (q *Queries) SearchMediaByName(ctx context.Context, arg SearchMediaByNameParams) ([]Medium, error) {
	rows, err := q.db.QueryContext(ctx, searchMediaByName, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Medium{}
	for rows.Next() {
		var i Medium
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Alt,
			&i.MediaPath,
			&i.UserID,
			&i.CreatedAt,
			&i.ChangedAt,
			&i.FileSize,
			&i.MimeType,
			&i.Width,
			&i.Height,
			&i.Duration,
			&i.OriginalFilename,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const transferMediaToUser = `-- name: TransferMediaToUser :exec
UPDATE media
SET user_id = $2
WHERE user_id = $1
`

type TransferMediaToUserParams struct {
	UserID   int64 `json:"user_id"`
	UserID_2 int64 `json:"user_id_2"`
}

func (q *Queries) TransferMediaToUser(ctx context.Context, arg TransferMediaToUserParams) error {
	_, err := q.db.ExecContext(ctx, transferMediaToUser, arg.UserID, arg.UserID_2)
	return err
}

const updateMedia = `-- name: UpdateMedia :one
UPDATE media
SET
    name = COALESCE($2, name),
    description = COALESCE($3, description),
    alt = COALESCE($4, alt),
    media_path = COALESCE($5, media_path),
    file_size = COALESCE($6, file_size),
    mime_type = COALESCE($7, mime_type),
    width = COALESCE($8, width),
    height = COALESCE($9, height),
    duration = COALESCE($10, duration),
    original_filename = COALESCE($11, original_filename),
    changed_at = now()
WHERE id = $1
RETURNING id, name, description, alt, media_path, user_id, created_at, changed_at, file_size, mime_type, width, height, duration, original_filename, metadata
`

type UpdateMediaParams struct {
	ID               int64  `json:"id"`
	Name             string `json:"name"`
	Description      string `json:"description"`
	Alt              string `json:"alt"`
	MediaPath        string `json:"media_path"`
	FileSize         int64  `json:"file_size"`
	MimeType         string `json:"mime_type"`
	Width            int32  `json:"width"`
	Height           int32  `json:"height"`
	Duration         int32  `json:"duration"`
	OriginalFilename string `json:"original_filename"`
}

func (q *Queries) UpdateMedia(ctx context.Context, arg UpdateMediaParams) (Medium, error) {
	row := q.db.QueryRowContext(ctx, updateMedia,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Alt,
		arg.MediaPath,
		arg.FileSize,
		arg.MimeType,
		arg.Width,
		arg.Height,
		arg.Duration,
		arg.OriginalFilename,
	)
	var i Medium
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Alt,
		&i.MediaPath,
		&i.UserID,
		&i.CreatedAt,
		&i.ChangedAt,
		&i.FileSize,
		&i.MimeType,
		&i.Width,
		&i.Height,
		&i.Duration,
		&i.OriginalFilename,
		&i.Metadata,
	)
	return i, err
}
